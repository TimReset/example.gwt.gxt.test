package ru.timreset.example.gxt.client.activity;

import com.google.gwt.activity.shared.Activity;
import com.google.gwt.activity.shared.ActivityMapper;
import com.google.gwt.event.shared.EventBus;
import com.google.gwt.place.shared.Place;
import com.google.gwt.place.shared.PlaceController;
import com.google.gwt.user.client.ui.AcceptsOneWidget;

/**
 * Базовый интерфейс для Activity ({@link Activity}). Обеспечивает точное соответствие между конкретным Place ({@link
 * Place}). Нужен, чтобы унифицировать мапинг между Place и Activity для ActivityMapper ({@link ActivityMapper}).
 * <p/>
 * <p/>
 * Use case использования Activity такой:
 * <p/>
 * Activity инициализирует и настраивает все Preseneter'ы, которые будут им показываться. Связь Presenter'ов между собой
 * и Activity происходит через EventBus, которые Activity должен явно передать Presenter'у. EventBus используется тот,
 * который передаётся в Activity в методе {@link Activity#start(AcceptsOneWidget, EventBus)}. Этот EventBus - надстройка
 * над глобальным EventBus, который инициализируется GIN. Главное отличие в том, handler'ы очищаются после закрытия
 * Activity. Таким образом при каждом показе Activity добавляются нужные handler'ы, которые будут работать только во
 * время показа этой Activity и будут автоматически очищаться после перехода с этой Activity.
 * <p/>
 * Передача своего EventBus в Presenter'ы и вообще использование event'ов нужны чтобы сделать Presenter'ы максимально
 * независимыми и модульными. Благодаря этому их можно использовать в разных местах. Например, есть Presenter "Список
 * Параметров" ({@link ParametersList}). Он может выводить просто список Параметров, а можно его же использовать для
 * выбора Параметра при редактировании Блока. И чтобы организовать связь между списком Параметров и редактированием
 * Блока нужен EventBus и Activity, который свяжет event'ы "списка Параметров" и "редактирование Блока". Т.о. "список
 * Параметров" можно использовать в любом месте, где нужен выбор Параметра, а не только при редактировании Блока. И это
 * использование будет заключаться <b>только</b> в добавлении event handler'а в Activity, в которой нужен будет этот
 * "список Параметров". Т.о. Presenter'ы становятся максимально независимыми и общаются с внешним миром <b>только</b> с
 * помощью event'ов. А Activity в этом случае являются связующим звеном между Presenter'ами. Минус этого решения -
 * каждая Activity каждый раз должна сама создавать связи между Presenter'ами. Пример - на "списке Параметров" есть
 * кнопка "Создать параметр", по нажатию на который открывается страница "Редактирования Параметра". Если использовать
 * event'ы, то Activity "Список Параметров" и Activity "Редактирование Блока" должны каждый для себя обрабатывать
 * event'ы нажатия на кнопку "Создать параметр". Activity "Список Параметров" для этого event'а будет просто переходить
 * на Place создания Параметра, а Activity "Редактирование Блока" будет у себя же показывать Presenter "Редактирование
 * Параметра". Во втором случае в историю не будут попадать эти действия (что и нужно, т.к. эти действия нельзя
 * корректно сериализовать в токен и потом его обработать). Если в Presenter "Список Параметров" добавится ещё какая
 * нибудь кнопка, то её обработку нужно будет также прописать во всех местах, где этот Presenter используется. Ещё минус
 * - большое количество event'ов. Фактически будет по два класса (event и event handler) на каждое событие Presentr'а.
 * Заменить event'ы явным назначением callback'ов в Presenter'ы нельзя - можно забыть обнулить/установить callback и
 * получить утечку памяти. Как раз сейчас Activity от этого избавлены тем, что EventBus всегда сам очищается.
 * <p/>
 * В противовес этому решению можно использовать Place - Presenter'ы переходят друг на друга прямым вызовом {@link
 * PlaceController#goTo(Place)}. Но в этом случае жёстко задаётся связь между Presenter'ами и нужно будет передавать в
 * Place "списка Параметров" (возвращаясь к нашему примеру) ещё параметры, чтобы можно было вернуться на редактирование
 * Блока, т.к. в этом случае при переходе на "список Параметров" будет загружена новая Activity и будет потеряна
 * информация, что сейчас происходит редактирование Блока. Так же в случае использования Presenter'а "Список Параметров"
 * ещё в другом месте, кроме как Activity "Редактирование Блока" и Activity "Список Параметров", нужно будет изменять
 * Place "списка параметров" что бы он поддерживал новый use case и чтобы в этом Place было записано, откуда он
 * вызвался. Плюс нужно будет менять Place других Activity (в нашем примере - "Редактирование Параметра"), чтобы при
 * переходе на эти Activity из "Списка Параметров" передавалась информация, что этот "список Параметров" был открыт на
 * выбор Параметра из "редактирования Блока". Т.е. получается зависимость Presenter'ов и Place друг от друга. А это не
 * правильно. По крайней мере теория по ООП говорит о том, что классы должны быть между собой слабо связаны. На что
 * намекает повсеместное использование DI.
 *
 * @author averin
 * @date 17.11.2014
 */
public interface BaseActivity<T extends Place> extends Activity {
  /**
   * Возвращает класс Place, который поддерживается этой Activity. Нужно, чтобы сделать соответствие между Place и
   * Activity.
   *
   * @return Place.
   */
  Class<T> getPlace();

  /**
   * Инициализирует Activity конкретным Place. Нужно, чтобы Activity получил данные из Place.
   *
   * @param place Place, которым будет инициализирована Activity.
   */
  Activity init(T place);
}
